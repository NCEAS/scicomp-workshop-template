[
  {
    "objectID": "join.html#workshop-topic-heading",
    "href": "join.html#workshop-topic-heading",
    "title": "Join",
    "section": "Workshop Topic Heading",
    "text": "Workshop Topic Heading\n\nDuplicate this file (or create new .qmd files) for each major section of the workshop. **Remember to add it to the “_quarto.yml” and run quarto render in the Terminal to add the page to the deployed website!**\ndplyr::…_join() functions\n\nWorkshop Subheading\nIt is worthwhile to use two “#” for headings and three “#” for subheadings to that the live table of the contents on the right hand side of the deployed website allows easy navigation among sections."
  },
  {
    "objectID": "index.html#programs-to-install",
    "href": "index.html#programs-to-install",
    "title": "Overview",
    "section": "Programs to Install",
    "text": "Programs to Install\n\nR & RStudio\nInstall R and its more convenient (in our opinion) user-interface: RStudio.\nIf you already have R, check that you have at least version 4.0.0 by running the following code:\n\nversion$version.string\n\nIf your version starts with a 3 (e.g., the above code returns “R version 3…”), please update R to make sure all packages behave as expected.\n\n\nR Packages\nInstall the tidyverse and palmerpenguins R packages using the following code:\n\ninstall.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nPlease run the above code even if you already have these packages to update these packages and ensure that your code aligns with the examples and challenges introduced during the workshop."
  },
  {
    "objectID": "index.html#websites-to-visit",
    "href": "index.html#websites-to-visit",
    "title": "Overview",
    "section": "Websites to Visit",
    "text": "Websites to Visit\n\nSupplemental Material\nWhile not technically necessary to attend the workshop, if you’d like you can see the content that created the workshop website you are viewing by visiting our GitHub repository here."
  },
  {
    "objectID": "wrangle.html#workshop-topic-heading",
    "href": "wrangle.html#workshop-topic-heading",
    "title": "Wrangle",
    "section": "Workshop Topic Heading",
    "text": "Workshop Topic Heading\n\nDuplicate this file (or create new .qmd files) for each major section of the workshop. **Remember to add it to the “_quarto.yml” and run quarto render in the Terminal to add the page to the deployed website!**\ndplyr::select with dplyr::contains() dplyr::filter() with logical and boolean operators tidyr::separate() dplyr::mutate() dplyr::case_when()\n\nWorkshop Subheading\nIt is worthwhile to use two “#” for headings and three “#” for subheadings to that the live table of the contents on the right hand side of the deployed website allows easy navigation among sections."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#julien-brun",
    "href": "about.html#julien-brun",
    "title": "Content Creators",
    "section": "Julien Brun",
    "text": "Julien Brun\nbrunj7.github.io –  brunj7 –  @brunj7 – brun@nceas.ucsb.edu\n\nAs a senior data scientist, the core of Julien’s work is to understand the data and computing challenges researchers are facing and help them to translate these challenges into solvable tasks. Julien advises and mentors on how to clean, structure, combine, and analyze their heterogeneous data sets, as well as scaling up their analysis while promoting open and reproducible data science principles.\nJulien is also a Lecturer in the Master in Environmental Data Science program at Bren School of Environmental Science and Management at UC Santa Barbara, where he teaches “good enough” practices in reproducible and collaborative data science."
  },
  {
    "objectID": "about.html#angel-chen",
    "href": "about.html#angel-chen",
    "title": "Content Creators",
    "section": "Angel Chen",
    "text": "Angel Chen\n angelchen7 – anchen@nceas.ucsb.edu\n\nAngel supports LTER synthesis working groups by developing data pipelines and reproducible analytical workflows to integrate various sources of data. Angel previously worked as a data curator for the Arctic Data Center, helping researchers archive and store their data. Angel recently completed a B.S. in statistics & data science at the University of California, Santa Barbara."
  },
  {
    "objectID": "about.html#nick-lyon",
    "href": "about.html#nick-lyon",
    "title": "Content Creators",
    "section": "Nick Lyon",
    "text": "Nick Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nAs a trained community ecologist, Nick is no stranger to the realities of “messy” environmental data and has learned the tidyverse as part of an effort to reproducibly manage those data for analysis and visualization. His zeal for the tidyverse is born out of the number of times these tools have allowed him to untangle a rat’s nest of idiodsyncratic data and he hopes this workshop will be valuable to all participants.Nick completed his MS in Ecology and Evolutionary Biology at Iowa State University"
  },
  {
    "objectID": "summarize.html#pipe-operator",
    "href": "summarize.html#pipe-operator",
    "title": "Summarize",
    "section": "Pipe Operator (%>%)",
    "text": "Pipe Operator (%>%)\n\nBefore diving into the tidyverse functions that allow for summarization and group-wise operations, let’s talk about the pipe operator (%>%). The pipe is from the magrittr package and allows chaining together multiple functions without needing to create separate objects at each step as you would have to without the pipe.\n\nExample: Pipe\nAs in the other chapters, let’s use the “penguins” data object found in the palmerpenguins package. Let’s say we want to keep only specimens that have a measurement for both bill length and bill depth and then remove the flipper and body mass columns.\nWithout the pipe–but still using other tidyverse functions–we could go about this like this: ::: {.cell}\n# Filter out the NAs\npenguins_v2 <- dplyr::filter(.data = penguins,\n                              !is.na(bill_length_mm) & !is.na(bill_depth_mm))\n\n# Now strip away the columns we don't want\npenguins_v3 <- dplyr::select(.data = penguins_v2, \n                             -flipper_length_mm, -body_mass_g)\n\n# And we can look at our final product with `base::head`\nhead(penguins_v3)\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n:::\nUsing the pipe though we can simplify this code dramatically! Note that each of the following lines must end with the %>% so that R knows there are more lines to consider. ::: {.cell}\n# We begin with the name of the data object\npenguins %>%\n  # Then we can filter the data\n  dplyr::filter(!is.na(bill_length_mm) & !is.na(bill_depth_mm)) %>%\n  # And strip away the columns we don't want\n  dplyr::select(-flipper_length_mm, -body_mass_g) %>%\n  # And we can even include the `head` argument to see our progress\n  head()\n\n# A tibble: 6 × 6\n  species island    bill_length_mm bill_depth_mm sex     year\n  <fct>   <fct>              <dbl>         <dbl> <fct>  <int>\n1 Adelie  Torgersen           39.1          18.7 male    2007\n2 Adelie  Torgersen           39.5          17.4 female  2007\n3 Adelie  Torgersen           40.3          18   female  2007\n4 Adelie  Torgersen           36.7          19.3 female  2007\n5 Adelie  Torgersen           39.3          20.6 male    2007\n6 Adelie  Torgersen           38.9          17.8 female  2007\n\n:::\nNote that using the pipe allows each line to inherit the data provided by the previous line.\n\n\nChallenge: Pipe\nUsing pipes, filter the data to only include male penguins, keep only the columns for species, island, and body mass, and drop any rows with NA for body mass.\n\n\nAside: Fun History of Why %>% is a “Pipe”\nThe Belgian painter René Magritte famously created a painting titled “The Treachery of Images” featuring a depiction of a smoking pipe above the words “Cest ci n’est pas une pipe” (French for “This is not a pipe”). Magritte’s point was about how the depiction of a thing is not equal to thing itself. The magrittr package takes its name from the painter because it also includes a pipe that functions slightly differently from a command line pipe and uses different characters. Just like Magritte’s pipe, %>% both is and isn’t a pipe!"
  },
  {
    "objectID": "summarize.html#group-wise-summarizing",
    "href": "summarize.html#group-wise-summarizing",
    "title": "Summarize",
    "section": "Group-Wise Summarizing",
    "text": "Group-Wise Summarizing\nNow that we’ve covered the %>% operator we can use it to do group-wise summarization! Technically this summarization does not require the pipe but it does inherently have two steps and thus benefits from using the pipe to chain together those technically separate instructions.\nTo summarize by groups we first define our groups using dplyr’s group_by function and then summarize using summarize (also from dplyr). summarize does require you to specify what calculations you want to perform within your groups though it uses similar syntax to dplyr’s mutate function.\nDespite the similarity in syntax between summarize and mutate there are a few crucial differences:\n\nsummarize returns only a single row per group while mutate returns as many rows as are in the original dataframe\nsummarize will automatically remove any columns that aren’t either (1) included in group_by or (2) created by summarize. mutate cannot remove columns so it only creates whatever you tell it to.\n\n\nExample: Summarize\nLet’s say we want to find some summary values for body mass of each species of penguin on each island. To accomplish this we can do the following:\n\n# Begin with the data and a pipe\npenguins %>%\n  # Group by the desired column names\n  dplyr::group_by(species, island) %>%\n  # And summarize in the way we desire\n  dplyr::summarise(\n    # Get average body mass\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    # Get the standard deviation\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    # Count the number of individual penguins of each species at each island\n    n_mass = dplyr::n(),\n    # Calculate standard error from SD and count\n    se_mass = sd_mass / n_mass )\n\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    mean_mass_g sd_mass n_mass se_mass\n  <fct>     <fct>           <dbl>   <dbl>  <int>   <dbl>\n1 Adelie    Biscoe          3710.    488.     44   11.1 \n2 Adelie    Dream           3688.    455.     56    8.13\n3 Adelie    Torgersen       3706.    445.     52    8.56\n4 Chinstrap Dream           3733.    384.     68    5.65\n5 Gentoo    Biscoe          5076.    504.    124    4.07\n\n\nYou can see we also invoked the n function from dplyr to return the size of each group. This function reads any groups created by group_by and returns the count of rows in the dataframe for each group level.\n\n\nChallenge: Summarizing\nUsing what we’ve covered so far, find the number of penguins sampled in each year (regardless of any other grouping variable)."
  },
  {
    "objectID": "summarize.html#grouping-cautionary-note",
    "href": "summarize.html#grouping-cautionary-note",
    "title": "Summarize",
    "section": "Grouping Cautionary Note",
    "text": "Grouping Cautionary Note\ngroup_by can be extremely useful in summarizing a dataframe or creating a new column without losing rows but you need to be careful. Objects created with group_by “remember” their groups until you change the groups or use the function ungroup from dplyr.\nLook at how the output of a grouped data object tells you the number of groups in the output (see beneath this code chunk).\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n())\n\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nThis means that all future uses of that pipe will continue to use the grouping established to create the “penguins_count” column. We can stop this by doing the same pipe, but adding ungroup after we’re done using the grouping established by group_by.\n\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n()) %>%\n  dplyr::ungroup()\n\n# A tibble: 5 × 3\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nSee? We calculated with our desired groups but then dropped the grouping structure once we were finished with them. Note also that if you use group_by and do some calculation then re-group by something else by using group_by again, the second use of group_by will not be affected by the first. This means that you only need one ungroup per pipe."
  },
  {
    "objectID": "reshape.html#defining-shape",
    "href": "reshape.html#defining-shape",
    "title": "Reshape",
    "section": "Defining Shape",
    "text": "Defining Shape\n\nBefore talking about how to reshape your data between wide and long format, let’s talk about what “shape” means in reference to data. Fundamentally, “long” data are data with more rows than columns while “wide” data tend to have more columns than rows.\nFor example, in community ecology a “wide” dataframe could have each row being a site that researchers visited while each column could be a different species where the value in the row is the number of individuals of that species at that site. On the other hand, the penguins dataframe we’ve been working with so far is in “long” format because it has one row per penguin and multiple penguins are stacked up.\nBoth wide and long format data can be useful in certain contexts and it is sometimes most intuitive to reshape data from one form to the other (and sometimes back again to the original form!).\nThe tidyr package contains the intuitively-named pivot_wider and pivot_longer for doing exactly this reshaping.\nTo help demonstrate these two functions, let’s begin by summarizing our dataframe to make changing the shape of the dataframe more visible than it would be with the full dataframe. For example, let’s calculate the average bill length of each penguin species on each island.\n\n# Begin by naming our new data and the data they come from\npenguins_simp <- penguins %>%\n  # Now group by species and island\n  dplyr::group_by(species, island) %>%\n  # Calculate average bill length\n  dplyr::summarize(avg_bill_length_mm = mean(bill_length_mm, na.rm = TRUE)) %>%\n  # And don't forget to ungroup!\n  dplyr::ungroup()\n\n# And this is what we're left with:\npenguins_simp\n\n# A tibble: 5 × 3\n  species   island    avg_bill_length_mm\n  <fct>     <fct>                  <dbl>\n1 Adelie    Biscoe                  39.0\n2 Adelie    Dream                   38.5\n3 Adelie    Torgersen               39.0\n4 Chinstrap Dream                   48.8\n5 Gentoo    Biscoe                  47.5\n\n\nGreat! We can use this smaller data object to demonstrate reshaping more clearly."
  },
  {
    "objectID": "reshape.html#reshaping-data",
    "href": "reshape.html#reshaping-data",
    "title": "Reshape",
    "section": "Reshaping Data",
    "text": "Reshaping Data\n\nExample: Reshaping Wider\nLet’s begin with pivot_wider. Let’s say that we want to take that data object and reshape it into wide format so that each island is a column and each species of penguin is a row. The contents of each cell then are going to be the average bill length values that we just calculated.\n\n# Begin by naming the objects\npenguins_wide <- penguins_simp %>%\n  # And now we can pivot wider with `pivot_wider`!\n  tidyr::pivot_wider(\n    names_from = island,\n    values_from = avg_bill_length_mm )\n\n# Take a look!\npenguins_wide\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  <fct>      <dbl> <dbl>     <dbl>\n1 Adelie      39.0  38.5      39.0\n2 Chinstrap   NA    48.8      NA  \n3 Gentoo      47.5  NA        NA  \n\n\nGreat! We now have each island as a column, each row is a penguin species, and the bill length measurement we took is included in each cell. Note that in this specific case this makes the number somewhat ambiguous so we might want to use dplyr’s select or the more specific rename to change the island names to be clearer that those values are bill lengths in milimeters.\n\n\nExample: Reshaping Longer\nNow that we have a small wide format data object, we can feed it to pivot_longer and reshape our data into long format! pivot_longer has very similar syntax except that with pivot_longer you need to tell the function which columns should be reshaped.\npivot_wider on the other hand knows which columns to move around because you manually specify them in the “names_from” and “values_from” arguments.\n\n# Begin with our wide data\npenguins_wide %>%\n  # And reshape back into long format\n  pivot_longer(\n    cols = -species,\n    names_to = \"island_name\",\n    values_to = \"mean_bill_length_mm\" )\n\n# A tibble: 9 × 3\n  species   island_name mean_bill_length_mm\n  <fct>     <chr>                     <dbl>\n1 Adelie    Biscoe                     39.0\n2 Adelie    Dream                      38.5\n3 Adelie    Torgersen                  39.0\n4 Chinstrap Biscoe                     NA  \n5 Chinstrap Dream                      48.8\n6 Chinstrap Torgersen                  NA  \n7 Gentoo    Biscoe                     47.5\n8 Gentoo    Dream                      NA  \n9 Gentoo    Torgersen                  NA  \n\n\nTwo quick things to note here:\n\nFirst, pivot_longer included the cells that were NA in the wide version of the data.\n\nThis default behavior is really nice so that you don’t lose any cells implicitly (though you can always filter them out if you don’t want them!).\n\nSecond, you’ll note that in the “cols” argument I only told pivot_longer to not include the “species” column using the same notation you could use for the select function in the dplyr package.\n\nThis is very handy because it lets us write really concise values in the “cols” argument and the default becomes “everything except what was specified”.\nNote that we could have also said cols = Biscoe, Dream, Torgersen and achieved the same reshaping of the data.\n\n\n\n\nChallenge: Reshaping\nThe code below creates a data object that includes the flipper length of all Adelie penguins; what code would you add to reshape the data so that each sex is a column with flipper lengths in the cells?\n\npenguins %>%\n  # Keep only Adelie penguins of known sex\n  dplyr::filter(species == \"Adelie\" & !is.na(sex)) %>%\n  # Calculate the average flipper length by island and sex\n  dplyr::group_by(island, sex) %>%\n  dplyr::summarize(avg_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE)) %>%\n  # Ungroup (good practice to include this step!)\n  dplyr::ungroup()\n\n# A tibble: 6 × 3\n  island    sex    avg_flipper_length_mm\n  <fct>     <fct>                  <dbl>\n1 Biscoe    female                  187.\n2 Biscoe    male                    190.\n3 Dream     female                  188.\n4 Dream     male                    192.\n5 Torgersen female                  188.\n6 Torgersen male                    195."
  }
]